/*
 * generated by Xtext 2.21.0
 */
package org.agileware.natural.cucumber.formatting2

import com.google.inject.Inject
import org.agileware.natural.common.formatting2.NewlineCondenser
import org.agileware.natural.cucumber.cucumber.Background
import org.agileware.natural.cucumber.cucumber.DocString
import org.agileware.natural.cucumber.cucumber.Example
import org.agileware.natural.cucumber.cucumber.Feature
import org.agileware.natural.cucumber.cucumber.Meta
import org.agileware.natural.cucumber.cucumber.MetaTag
import org.agileware.natural.cucumber.cucumber.Scenario
import org.agileware.natural.cucumber.cucumber.ScenarioOutline
import org.agileware.natural.cucumber.cucumber.Section
import org.agileware.natural.cucumber.cucumber.Step
import org.agileware.natural.cucumber.cucumber.Table
import org.agileware.natural.cucumber.cucumber.TableCol
import org.agileware.natural.cucumber.cucumber.TableRow
import org.agileware.natural.cucumber.services.CucumberGrammarAccess
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion
import org.eclipse.xtext.formatting2.regionaccess.internal.NodeSemanticRegion

import static org.agileware.natural.cucumber.cucumber.CucumberPackage.Literals.*

/**
 * See: https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#formatting
 */
class CucumberFormatter extends AbstractFormatter2 {

	@Inject extension CucumberGrammarAccess

	def dispatch void format(Feature model, extension IFormattableDocument document) {
		println(textRegionAccess)

		condenseLineBreaks(model, document)

		// cleanup whitespace
		if (model.title === null) {
			val keyword = model.regionFor.keyword("Feature:")
			keyword.surround[noSpace]
		}

		// format features
		model.meta.format()
		model.background.format()
		for (s : model.scenarios) {
			s.format()
		}

		println(document)
	}

	def dispatch void format(Background model, extension IFormattableDocument document) {

		condenseLineBreaks(model, document)
		model.prepend[setNewLines(2)]

		// cleanup whitespace
		if (model.title === null) {
			val keyword = model.regionFor.keyword("Background:")
			keyword.surround[noSpace]
		}

		// Indent interior
		val begin = model.regionFor.ruleCallTo(EOLRule)
		val end = model.steps.last.regionFor.ruleCallTo(EOLRule)
		interior(begin, end)[indent]

		// format features
		for (s : model.steps) {
			s.format()
			s.prepend[indent]
		}
	}

	def dispatch void format(Scenario model, extension IFormattableDocument document) {

		condenseLineBreaks(model, document)
		model.prepend[setNewLines(2)]

		// cleanup whitespace
		if (model.title === null) {
			val keyword = model.regionFor.keyword("Scenario:")
			keyword.surround[noSpace]
		}

		// Indent interior
		val begin = model.regionFor.ruleCallTo(EOLRule)
		val end = model.steps.last.regionFor.ruleCallTo(EOLRule)
		interior(begin, end)[indent]

		// Format features
		model.meta.format()
		for (s : model.steps) {
			s.format()
			s.prepend[indent]
		}
	}

	def dispatch void format(ScenarioOutline model, extension IFormattableDocument document) {

		condenseLineBreaks(model, document)
		model.prepend[setNewLines(2)]

		// cleanup whitespace
		if (model.title === null) {
			val keyword = model.regionFor.keyword("Scenario Outline:")
			keyword.surround[noSpace]
		}

		// Indent interior
		val begin = model.regionFor.ruleCallTo(EOLRule)
		val end = model.examples.last.table.rows.last.regionFor.ruleCallTo(EOLRule)
		interior(begin, end)[indent]

		// Format features
		model.meta.format()
		for (s : model.steps) {
			s.format()
			s.prepend[indent]
		}
		for (e : model.examples) {
			e.format()
			e.prepend[indent]
		}
	}

	def dispatch void format(Example model, extension IFormattableDocument document) {

		condenseLineBreaks(model, document)
		model.prepend[setNewLines(2)]

		// cleanup whitespace
		if (model.title === null) {
			val keyword = model.regionFor.keyword("Example:")
			keyword.surround[noSpace]
		}

		// Indent interior
		val begin = model.regionFor.ruleCallTo(EOLRule)
		val end = model.table.rows.last.regionFor.ruleCallTo(EOLRule)
		interior(begin, end)[indent]

		// Format features
		model.meta.format()
		model.table.format()
		model.table.prepend[indent]
	}

	def dispatch void format(Step model, extension IFormattableDocument document) {

		addNewlineCondenser(model.regionFor.ruleCallTo(EOLRule), document)
		
		// cleanup whitespace
		model.regionFor.feature(STEP__KEYWORD).prepend[noSpace].append[oneSpace]
		model.regionFor.feature(STEP__DESCRIPTION).append[noSpace]

		// Format features
		if (model.table !== null) {
			val begin = model.regionFor.ruleCallTo(EOLRule)
			val end = model.table.rows.last.regionFor.ruleCallTo(EOLRule)
			interior(begin, end)[indent]

			model.table.format()
			model.table.prepend[indent]
		} else if (model.code !== null) {
			model.code.format()
			model.code.prepend[indent]
		}
	}

	def dispatch void format(Meta model, extension IFormattableDocument document) {
		for (var i = 0; i < model.tags.size(); i++) {
			val tag = model.tags.get(i)
			tag.format()
			if (i > 0) {
				tag.prepend[setNewLines(1)]
			}
		}
	}

	def dispatch void format(MetaTag model, extension IFormattableDocument document) {

		// Cleanup whitespace
		model.regionFor.keyword('@').surround[noSpace]
		model.regionFor.feature(META_TAG__KEY).append[noSpace]

		if (model.value !== null) {
			model.regionFor.keyword(':').surround[noSpace]
			model.regionFor.feature(META_TAG__VALUE).append[noSpace]
		}
	}

	def dispatch void format(DocString model, extension IFormattableDocument document) {
		// Cleanup whitespace
		model.regionFor.keyword(docStringAccess.apostropheApostropheApostropheKeyword_1_1_0).surround[noSpace]
		model.regionFor.keyword(docStringAccess.apostropheApostropheApostropheKeyword_1_1_3).surround[noSpace]

		model.regionFor.keyword(docStringAccess.quotationMarkQuotationMarkQuotationMarkKeyword_1_0_0).surround [
			noSpace
		]
		model.regionFor.keyword(docStringAccess.quotationMarkQuotationMarkQuotationMarkKeyword_1_0_3).surround [
			noSpace
		]
	}

	def dispatch void format(Table model, extension IFormattableDocument document) {
		for (r : model.rows) {
			r.format()
			r.prepend[indent]
		}
	}

	def dispatch void format(TableRow model, extension IFormattableDocument document) {
		model.append[noSpace]
		for (c : model.cols) {
			c.format()
		}
	}

	def dispatch void format(TableCol model, extension IFormattableDocument document) {
		// TODO...
	}

	protected def condenseLineBreaks(Section model, extension IFormattableDocument document) {
		addNewlineCondenser(model.regionFor.ruleCallTo(EOLRule), document)
	}

	protected def addNewlineCondenser(ISemanticRegion region, extension IFormattableDocument document) {
		addReplacer(new NewlineCondenser(region as NodeSemanticRegion))
	}
}
