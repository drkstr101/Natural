/*
 * generated by Xtext 2.23.0-SNAPSHOT
 */
package org.agileware.natural.lang.formatting2

import com.google.inject.Inject
import java.util.Collections
import java.util.stream.Collectors
import org.agileware.natural.lang.model.DocString
import org.agileware.natural.lang.model.Document
import org.agileware.natural.lang.model.Meta
import org.agileware.natural.lang.model.Narrative
import org.agileware.natural.lang.model.NaturalModel
import org.agileware.natural.lang.model.Paragraph
import org.agileware.natural.lang.model.Section
import org.agileware.natural.lang.model.Table
import org.agileware.natural.lang.model.Tag
import org.agileware.natural.lang.services.NaturalGrammarAccess
import org.eclipse.xtext.formatting.IIndentationInformation
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.FormatterPreferenceKeys
import org.eclipse.xtext.formatting2.FormatterRequest
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion
import org.eclipse.xtext.preferences.MapBasedPreferenceValues

class NaturalFormatter extends AbstractFormatter2 {

	@Inject extension NaturalGrammarAccess naturalGrammarAccess

	@Inject IIndentationInformation indentationInformation

	@Inject MultilineTextFormatter.Factory textFormatterFactory

	// TODO there must be a better way to get the current indentation level!
	var int indentationLevel = -1

	override protected initialize(FormatterRequest request) {
		val preferences = request.preferences
		if (preferences instanceof MapBasedPreferenceValues) {
			preferences.put(FormatterPreferenceKeys.indentation, indentationInformation.indentString)
		}
		super.initialize(request)
	}

	def dispatch void format(NaturalModel model, extension IFormattableDocument doc) {
		println(textRegionAccess)
		model.document.format()
		println(doc)
	}

	def dispatch void format(Document model, extension IFormattableDocument doc) {
		val textFormatter = createTextFormatter()

		indentationLevel = 0

		// Format meta tags
		if (model.meta !== null) {
			model.meta.format()
			// textFormatter.trimBlankSpace(model, documentAccess.BLANK_SPACEParserRuleCall_6_0, 1, doc)
		}

		// Format title
		if (model.title === null) {
			model.regionFor.keyword(documentAccess.documentKeyword_3).append[noSpace]
		} else {
			model.regionFor.assignment(documentAccess.titleAssignment_4).prepend[oneSpace].append[noSpace]
		}

		// Indent block
		val start = model.regionFor.ruleCallTo(NLRule)
		val end = model.endRegion()
		interior(start, end)[indent]

		indentationLevel++

		// Format narrative
		if (model.narrative !== null) {
			model.narrative.format().prepend[indent]
		}

		// Format sections
		for (s : model.sections) {
			s.format().prepend[indent]
		}

		indentationLevel--
	}

	def dispatch void format(Section model, extension IFormattableDocument doc) {
		val textFormatter = createTextFormatter()

		// Format meta tags
		if (model.meta !== null) {
			model.meta.format()
			model.meta.tags.forEach[prepend[indent]]

			// Work-around for strange keyword placement when tags are present
			model.regionFor.keyword(sectionAccess.sectionKeyword_2).prepend[indent]
			// textFormatter.trimBlankSpace(model, sectionAccess.BLANK_SPACEParserRuleCall_1_1, 1, doc)
		}

		// Format title
		if (model.title === null) {
			model.regionFor.keyword(sectionAccess.sectionKeyword_2).append[noSpace]
		} else {
			model.regionFor.assignment(sectionAccess.titleAssignment_3).prepend[oneSpace].append[noSpace]
		}

		indentationLevel++

		// Format narrative
		if (model.narrative !== null) {
			// Indent block interior
			val start = model.regionFor.ruleCallTo(NLRule)
			val end = model.endRegion()
			interior(start, end)[indent]

			model.narrative.format().prepend[indent]
		}

		indentationLevel--
	}

	def dispatch void format(Meta model, extension IFormattableDocument doc) {
		val textFormatter = createTextFormatter()

		// trim blank space
		model.allRegionsFor.ruleCallsTo(BLANK_SPACERule).forEach [ region |
			textFormatter.trimBlankSpace(region, 1, doc)
		]

		model.tags.forEach[format]
	}

	def dispatch void format(Tag model, extension IFormattableDocument doc) {
		model.surround[noSpace]
		if (model.value !== null) {
			model.regionFor.keyword(':').prepend[noSpace].append[oneSpace]
			model.regionFor.assignment(tagAccess.valueAssignment_2_1).prepend[oneSpace].append[noSpace]
		}
		
		if(!model.isLast() && immediatelyFollowing(model).ruleCallTo(BLANK_SPACERule) === null) {
			model.append[newLine]
		}
	}

	def dispatch void format(Narrative model, extension IFormattableDocument doc) {

		// Format text blocks 
		for (s : model.sections) {
			s.format()
		}
	}

	def dispatch void format(Paragraph model, extension IFormattableDocument doc) {
		model.prepend[indent]
		createTextFormatter().formatTextBlock(model, paragraphAccess.valueAssignment_1, indentationLevel, doc)
	}

	def dispatch void format(Table model, extension IFormattableDocument doc) {
		model.rows.forEach[prepend[indent]]
	}

	def dispatch void format(DocString model, extension IFormattableDocument doc) {
		model.prepend[indent]
		createTextFormatter().formatTextBlock(model, docStringAccess.valueAssignment_1, indentationLevel, doc)
	}

	def MultilineTextFormatter createTextFormatter() {
		return textFormatterFactory.create(request.textRegionAccess)
	}

	def dispatch ISemanticRegion endRegion(Document model) {
		if (!model.sections.isEmpty()) {
			return model.sections.last.endRegion()
		} else if (model.narrative !== null) {
			return model.narrative.endRegion()
		}

		return model.regionFor.ruleCall(documentAccess.BLANK_SPACEParserRuleCall_8)
	}

	def dispatch ISemanticRegion endRegion(Section model) {
		if (model.narrative !== null) {
			return model.narrative.endRegion()
		}

		return model.regionFor.ruleCallTo(NLRule)
	}

	def dispatch ISemanticRegion endRegion(Narrative model) {
		return model.sections.last.endRegion()
	}

	def dispatch ISemanticRegion endRegion(Paragraph model) {
		return model.regionFor.ruleCallTo(NLRule)
	}

	def dispatch ISemanticRegion endRegion(DocString model) {
		return model.regionFor.ruleCallTo(NLRule)
	}

	def dispatch ISemanticRegion endRegion(Table model) {
		return model.rows.last.regionFor.ruleCallTo(NLRule)
	}

	def dispatch boolean isLast(Tag model) {
		val meta = model.eContainer as Meta
		model == meta.tags.last
	}
}
