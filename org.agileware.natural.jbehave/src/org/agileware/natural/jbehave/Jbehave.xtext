grammar org.agileware.natural.jbehave.Jbehave hidden(WS, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate jbehave "http://www.agileware.org/natural/jbehave"


// ----------------------------------------------------------
//
// Story
//
// ----------------------------------------------------------

// The story describes a feature via description, narrative and a set of scenarios
// Story := Description? Meta? Narrative? GivenStories? Lifecycle? Scenario+ ;
Story:
	description=Description?
	meta=Meta?
	narrative=Narrative?
	lifecycle=Lifecycle?
	scenarios+=Scenario*
;

// The Description is expressed by any sequence of words that must not contain any keywords at start of lines.
// Description := (Word Space?)* ;
Description:
	(TextLiteral TextLiteral* EOL+)+;


// ----------------------------------------------------------
//
// Meta
//
// ----------------------------------------------------------

// The meta is identified by keyword "Meta:" (or equivalent in I18n-ed locale),
// It is followed by any number of meta elements
// Meta:= "Meta:" (MetaElement)* ;
Meta:
	'Meta:' EOL+
	elements+=MetaElement
	(EOL? elements+=MetaElement)*
	EOL+
;

// The meta element is identified by keyword "@" (or equivalent in I18n-ed locale),
// It is followed by a name-value pair, where the value can be empty or have multiple words
// MetaElement:= "@" Space? Word Space (Word Space?)* ;
MetaElement:
	'@'
	key=WORD
	(':'? value=Text)?
;


// ----------------------------------------------------------
//
// Narrative
//
// ----------------------------------------------------------

// The narrative is identified by keyword "Narrative:" (or equivalent in I18n-ed locale),
// It is followed by the narrative elements
// Narrative:= "Narrative:" ( InOrderTo AsA IWantTo | AsA IWantTo SoThat ) ;
Narrative:
	NarrativeA | NarrativeB
;

NarrativeA: {NarrativeA}
	'Narrative:' EOL+
	inOrderTo=InOrderTo
	asA=AsA
	wantTo=IWantTo
;

NarrativeB: {NarrativeB}
	'Narrative:' EOL+
	asA=AsA
	wantTo=IWantTo
	soThat=SoThat
;

// InOrderTo:= "In order to" NarrativeElementContent ;
InOrderTo:
	IN_ORDER_TO content=Text EOL+
;

// AsA:= "As a" NarrativeElementContent ;
AsA:
	AS_A content=Text EOL+
;

// IWantTo:= "I want to" NarrativeElementContent ;
IWantTo:
	I_WANT_TO content=Text EOL+
;

// SoThat:= "So that" NarrativeElementContent ; 
SoThat:
	SO_THAT content=Text EOL+
;

terminal IN_ORDER_TO: 'In order to';

terminal AS_A: 'As a';

terminal I_WANT_TO: 'I want to';

terminal SO_THAT: 'So that';



// ----------------------------------------------------------
//
// Lifecycle
//
// ----------------------------------------------------------

// The lifecycle is identified by keyword "Lifecycle:" (or equivalent in I18n-ed locale),
// It is followed by the lifecycle elements
// Lifecycle:= "Lifecycle:" LifecycleBefore? LifecycleAfter?
Lifecycle: {Lifecycle} 
	'Lifecycle:' EOL+
	before=LifecycleBefore?
	after=LifecycleAfter?
;

// The before lifecyle element identified by keyword "Before:" (or equivalent in I18n-ed locale),
// followed by one or more steps
// LifecycleBefore:= "Before:" (Scope? Step+)+
LifecycleBefore:
	"Before:" EOL+
	elements+=LifecycleBeforeElement+
;

LifecycleBeforeElement:
	scope=Scope EOL+
	steps+=Step+
;

// The after lifecyle element identified by keyword "After:" (or equivalent in I18n-ed locale),
// followed by one or more sets of scope, outcome, meta filter and steps
// LifecycleAfter:= "After:" (Scope? Outcome? MetaFilter? Step+)+
LifecycleAfter:
	"After:" EOL+
	elements+=LifecycleAfterElement+
;

LifecycleAfterElement:
	scope=Scope EOL+
	(outcome=Outcome EOL+)?
	steps+=Step+
;

// The scope element identified by keyword "Scope:" (or equivalent in I18n-ed locale),
// Scope:= "Scope:" "STEP" | "SCENARIO" | "STORY"
Scope:
	"Scope:"
	type=ScopeType
;

enum ScopeType: STEP
	| SCENARIO
	| STORY
;

// The outcome element identified by keyword "Outcome:" (or equivalent in I18n-ed locale),
// Outcome:= "Outcome:" "ANY" | "SUCCESS" | "FAILURE" ;
Outcome:
	"Outcome:"
	type=OutcomeType
;

enum OutcomeType: ANY
	| SUCCESS
	| FAILURE
;


// ----------------------------------------------------------
//
// Scenario
//
// ----------------------------------------------------------
	
// The scenario is identified by keyword "Scenario:" (or equivalent in I18n-ed locale),
// which is optional in the case of a single scenario.
// It can optionally be followed by a title, which is expressed by any sequence of words
// that must not contain any keywords at start of lines.
// It is followed by one or more Steps.
// Scenarios can optionally contain comments (which are not part of the scenarios) after examples using "!--" keyword
// Scenario := "Scenario:"? Title? Meta? GivenStories? Step+ Examples? (Examples Comment+)? ;
Scenario:
	'Scenario:' title=Text? EOL+
	meta=Meta?
	given=GivenStories?
	steps+=Step+
	examples=Examples?
;

// The comma-separated list of story resources that specify the stories to be run before a story or a scenario
// GivenStories:= "GivenStories:" (StoryPath ','?)+ ;
GivenStories: 
	'GivenStories:'
	resources+=FilePath
	// TODO...
	// (-> ',' EOL? resources+=FilePath)*
	EOL+
;


// ----------------------------------------------------------
//
// Step
//
// ----------------------------------------------------------

// The scenario step is a step starting work followed by any number of characters
// Step := StepStartingWord StepContent ;
Step:
	GivenStep
	| WhenStep
	| ThenStep
	| AndStep
;

GivenStep:
	"Given" content=Text EOL+
;

WhenStep:
	"When" content=Text EOL+
;

ThenStep:
	"Then" content=Text EOL+
;

AndStep:
	"And" content=Text EOL+
;

// The examples table
// Examples := "Examples:" ExamplesTable ;
Examples:
	'Examples:' EOL+
	table=Table
;

// The examples table comprises of a header row and data rows
// ExamplesTable := ExamplesTableHeader ExamplesTableRow+ ;
Table:
	header=TABLE_ROW EOL
	(rows+=TABLE_ROW EOL)+
;

// The examples table header contains the column names, separated by ExamplesTableColumnSeparator
// ExamplesTableHeader := (ExamplesTableColumnSeparator ExamplesTableCharacter+)+ ExamplesTableColumnSeparator  Newline ;

// The examples table row contains the column values, separated by ExamplesTableColumnSeparator
// ExamplesTableRow := (ExamplesTableColumnSeparator ExamplesTableCharacter+)+ ExamplesTableColumnSeparator  Newline ;

// The examples table character can be any character, expect for ExamplesTableColumnSeparator and Newline
// ExamplesTableCharacter := ? Any Unicode character except ExamplesTableColumnSeparator and Newline ? ;
terminal TABLE_ROW: 
	'|' (TABLE_CELL '|')+
;

terminal fragment TABLE_CELL: !('|' | '\n' | '\r')*;


// ----------------------------------------------------------
//
// Common Elements
//
// ----------------------------------------------------------

FilePath returns ecore::EString:
	(WORD | './' | '../' | '/') WORD ('/' WORD)*
;

Text returns ecore::EString:
 	TextLiteral+
;

TextLiteral: EXAMPLE_WORD
	| WORD
	| PUNCTUATION
;

terminal EXAMPLE_WORD:
	('<' WORD '>')
	| ('[' WORD ']')
;

terminal WORD: 
	(LETTER | DIGIT)
	(LETTER | DIGIT | '_' | '-' | '.' )*
;

terminal SL_COMMENT:
	'!--'
	!('\n'|'\r')*
	('\r'? '\n')?
;

terminal PUNCTUATION: CHAR;

terminal EOL: NL;

terminal WS: (SPACE | '\t')+;

terminal fragment NL: ('\r'? | '\n');


// ----------------------------------------------------------
//
// Unicode Character Ranges
//
// ----------------------------------------------------------

terminal fragment CHAR: ASCII_CHAR;

terminal fragment SPACE: ASCII_SPACE;

terminal fragment DIGIT: ASCII_DIGIT;

terminal fragment LETTER: LATIN_ALPHABET;

// Basic Latin
////

terminal fragment ASCII_SPACE: '\u0020';

terminal fragment ASCII_DIGIT: ('\u0030'..'\u0039');

// all ascii chars other than letters, digits, or space
terminal fragment ASCII_CHAR: ('\u0021'..'\u002F')
	| ('\u003A'..'\u0040')
	| ('\u005B'..'\u0060')
	| ('\u007B'..'\u007E')
;

terminal fragment LATIN_ALPHABET: ('\u0041'..'\u005A')
	| ('\u0061'..'\u007A')
;
